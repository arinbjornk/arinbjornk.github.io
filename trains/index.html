
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Train Journeys by Arinbjörn | Interactive European Railway Map</title>
    <meta name="description" content="Explore long-distance train routes across Europe taken by Arinbjörn Kolbeinsson. Interactive map with animated route tracing and camera tracking.">
    <meta name="keywords" content="Arinbjörn Kolbeinsson, train travel, European railways, interactive map, train routes, rail travel, Europe travel, railway visualization">
    <meta name="author" content="Arinbjörn Kolbeinsson">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://arinbjorn.is/trains/">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Social media meta tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@arinbjornkol">
    <meta name="twitter:title" content="Train Journeys by Arinbjörn | Interactive European Railway Map">
    <meta name="twitter:description" content="Explore long-distance train routes across Europe with interactive animations and camera tracking.">
    <meta name="twitter:image" content="https://arinbjorn.is/trains/preview.jpg">
    
    <meta property="og:title" content="Train Journeys by Arinbjörn | Interactive European Railway Map">
    <meta property="og:url" content="https://arinbjorn.is/trains/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://arinbjorn.is/trains/preview.jpg">
    <meta property="og:description" content="Explore long-distance train routes across Europe taken by Arinbjörn Kolbeinsson. Interactive map with animated route tracing and camera tracking.">
    <meta property="og:site_name" content="Arinbjörn Kolbeinsson">

    <!-- Structured data for search engines -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "Train Journeys by Arinbjörn",
        "description": "Interactive map showing long-distance train routes across Europe taken by Arinbjörn Kolbeinsson",
        "url": "https://arinbjorn.is/trains/",
        "author": {
            "@type": "Person",
            "name": "Arinbjörn Kolbeinsson",
            "url": "https://arinbjorn.is",
            "sameAs": [
                "https://scholar.google.co.uk/citations?user=MiI7lj0AAAAJ&hl=en",
                "https://github.com/arinbjornk",
                "https://www.linkedin.com/in/arinbjorn",
                "https://bsky.app/profile/arinbjorn.is",
                "https://x.com/arinbjornkol"
            ]
        },
        "mainEntity": {
            "@type": "Map",
            "name": "European Train Routes by Arinbjörn",
            "description": "Interactive visualization of train journeys across Europe"
        },
        "breadcrumb": {
            "@type": "BreadcrumbList",
            "itemListElement": [
                {
                    "@type": "ListItem",
                    "position": 1,
                    "name": "Home",
                    "item": "https://arinbjorn.is"
                },
                {
                    "@type": "ListItem",
                    "position": 2,
                    "name": "Train Journeys",
                    "item": "https://arinbjorn.is/trains/"
                }
            ]
        }
    }
    </script>
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <!-- Fonts matching your website -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,300;8..60,400&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables matching your website */
        :root {
            --primary-color: #252525;
            --text-color: #333333;
            --background-card: rgba(255, 255, 255, 0.25);
            --theme-rail: #8B4513;      /* Retro brown for railways */
            --theme-vintage: #D2691E;   /* Vintage orange */
            --transition-standard: all 0.3s ease;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #65C0D4;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: var(--background-card);
            backdrop-filter: blur(30px);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 350px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: var(--transition-standard);
        }

        .map-overlay.dark-theme {
            background: rgba(0, 0, 0, 0.7);
            color: #ffffff;
        }

        .map-overlay.dark-theme h3 {
            color: #ffffff;
        }

        .map-overlay.dark-theme p {
            color: #cccccc;
        }

        .map-overlay.dark-theme .basemap-selector label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .camera-mode label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .camera-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .camera-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .map-overlay.dark-theme .camera-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            color: #ffffff;
        }

        .map-overlay.dark-theme .back-link {
            color: #ffffff;
        }

        .map-overlay.dark-theme .attributions p {
            color: #aaa;
        }

        .map-overlay.dark-theme .attributions a {
            color: #aaa;
        }

        .map-overlay.dark-theme .attributions a:hover {
            color: #ffffff;
        }

        .map-overlay.dark-theme .legend-item.animating::after {
            color: #ffffff;
        }

        .map-overlay.dark-theme .basemap-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .basemap-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .map-overlay.dark-theme .basemap-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            color: #ffffff;
        }

        .map-overlay h3 {
            font-family: 'Source Serif 4', serif;
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 400;
            color: var(--primary-color);
        }

        .map-overlay p {
            margin: 0 0 10px 0;
            color: #666;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .legend-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
            position: relative;
        }

        .legend-item {
            position: relative;
        }

        .legend-item.animating::after {
            content: '';
            position: absolute;
            right: 6px;
            top: 50%;
            width: 14px;
            height: 14px;
            background-image: url('train-wheel.svg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translateY(-50%);
            animation: trainWheel 1.5s linear infinite;
            transform-origin: center center;
        }

        .legend-item.completed::after {
            content: '✓';
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #4CAF50;
            font-weight: bold;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes trainWheel {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        .maplibregl-ctrl-logo {
            display: none !important;
        }

        .basemap-selector {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .basemap-selector label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .basemap-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .basemap-btn {
            flex: 1;
            min-width: 50px;
            padding: 6px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 10px;
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition-standard);
        }

        .basemap-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .basemap-btn.active {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            color: var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .camera-mode {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .camera-mode label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .camera-buttons {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .camera-btn {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 10px;
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition-standard);
        }

        .camera-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .camera-btn.active {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            color: var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .back-link {
            color: var(--primary-color);
            text-decoration: none;
            transition: var(--transition-standard);
        }

        .back-link:hover {
            opacity: 0.7;
        }

        .attributions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .attributions p {
            font-size: 10px;
            line-height: 1.4;
            color: #999;
            margin: 0;
        }

        .attributions a {
            color: #999;
            text-decoration: none;
        }

        .attributions a:hover {
            color: var(--primary-color);
        }

        /* Desktop header styling */
        .map-overlay h3 {
            font-family: 'Source Serif 4', serif;
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 400;
            color: var(--primary-color);
        }

        /* Hide mobile elements on desktop */
        .mobile-header {
            display: none;
        }

        .expand-button {
            display: none;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            .map-overlay {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                max-width: none;
                border-radius: 1rem 1rem 0 0;
                padding: 1rem;
                transform: translateY(calc(100% - 80px));
                transition: transform 0.3s ease;
                z-index: 1000;
            }

            .map-overlay.expanded {
                transform: translateY(0);
            }

            .map-overlay > h3:not(.mobile-header h3) {
                display: none; /* Hide desktop header on mobile */
            }

            .mobile-header h3 {
                font-size: 14px;
                margin: 0;
            }

            .map-overlay p {
                font-size: 12px;
                margin: 0 0 8px 0;
                display: none; /* Hide description when collapsed */
            }

            .map-overlay.expanded p {
                display: block;
            }

            .mobile-header {
                display: flex !important;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                cursor: pointer;
            }

            .expand-button {
                display: block !important;
                background: none;
                border: none;
                color: var(--text-color);
                font-size: 18px;
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: var(--transition-standard);
            }

            .expand-button:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .legend {
                display: none;
            }

            .map-overlay.expanded .legend {
                display: flex;
            }

            .basemap-buttons {
                gap: 4px;
            }

            .basemap-btn {
                font-size: 9px;
                padding: 4px 6px;
                min-width: 40px;
            }

            .camera-mode {
                margin-top: 10px;
                padding-top: 10px;
            }

            .camera-mode label {
                font-size: 11px;
            }

            .camera-btn {
                font-size: 9px;
                padding: 4px 6px;
            }

            .attributions {
                margin-top: 10px;
                padding-top: 10px;
                display: none;
            }

            .map-overlay.expanded .attributions {
                display: block;
            }

            /* Dark theme mobile adjustments */
            .map-overlay.dark-theme .expand-button {
                color: #ffffff;
            }

            .map-overlay.dark-theme .mobile-header h3 {
                color: #ffffff;
            }
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="map-overlay">
        <h3>Train Journeys by Arinbjörn</h3>
        <div class="mobile-header">
            <h3>Train Journeys by Arinbjörn</h3>
            <button class="expand-button" id="expand-btn">▲</button>
        </div>
        <p>Long-distance train routes Arinbjörn has taken across Europe. Click any route below to watch it trace out on the map.</p>
        <p style="margin-top: 15px; font-size: 11px;"><a href="../index.html" class="back-link">← arinbjorn.is</a></p>
        <div class="legend" id="legend"></div>
        <div class="basemap-selector">
            <label>Map Style:</label>
            <div class="basemap-buttons">
                <button class="basemap-btn active" data-style="positron">Clean</button>
                <button class="basemap-btn" data-style="voyager">Detailed</button>
                <button class="basemap-btn" data-style="humanitarian">OSM</button>
                <button class="basemap-btn" data-style="topo">Topo</button>
                <button class="basemap-btn" data-style="dark">Dark</button>
            </div>
        </div>
        <div class="camera-mode">
            <label>View Mode:</label>
            <div class="camera-buttons">
                <button class="camera-btn active" data-mode="static">Static View</button>
                <button class="camera-btn" data-mode="tracking">Follow Route</button>
            </div>
        </div>
        <div class="attributions">
            <p>Rail data: <a href="https://signal.eu.org/osm" target="_blank">signal.eu.org/osm</a><br>
            Maps: Carto, OpenStreetMap, Stamen, Stadia Maps<br>
            Built with MapLibre GL JS</p>
        </div>
    </div>

    <script>
        // Financial Times inspired color palette
        const FT_COLORS = {
            background: '#f6f2e7',
            primary: '#990f3d',
            secondary: '#0d7680',
            accent1: '#a7a59b',
            accent2: '#cc8b65',
            accent3: '#6f7755',
            text: '#33302e',
            textLight: '#66605c'
        };

        // Professional route colors inspired by FT style
        const ROUTE_COLORS = [
            '#990f3d', // FT burgundy
            '#0d7680', // teal
            '#cc8b65', // warm orange
            '#6f7755', // olive
            '#9e2f50', // deep pink
            '#2e6091', // blue
            '#b85aa6', // purple
            '#0f5499'  // navy
        ];

        // Enhanced route colors for topographic map - same hues, better contrast
        const TOPO_ROUTE_COLORS = [
            '#d91b60', // brighter burgundy/pink
            '#00acc1', // brighter teal/cyan
            '#ff8a50', // brighter orange
            '#8bc34a', // brighter green
            '#e91e63', // bright pink
            '#1976d2', // bright blue
            '#9c27b0', // bright purple
            '#3f51b5'  // bright indigo
        ];

        // Basemap styles configuration
        const BASEMAP_STYLES = {
            positron: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            voyager: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
            dark: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            humanitarian: {
                version: 8,
                sources: {
                    'osm-humanitarian': {
                        type: 'raster',
                        tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [
                    {
                        id: 'osm-humanitarian',
                        type: 'raster',
                        source: 'osm-humanitarian',
                        paint: {
                            'raster-opacity': 0.75,
                            'raster-saturation': -0.5,
                            'raster-contrast': -0.2,
                            'raster-brightness-max': 0.9
                        }
                    }
                ]
            },
            topo: {
                version: 8,
                sources: {
                    'stamen-terrain': {
                        type: 'raster',
                        tiles: ['https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© Stadia Maps, © Stamen Design, © OpenMapTiles, © OpenStreetMap contributors'
                    }
                },
                layers: [
                    {
                        id: 'stamen-terrain',
                        type: 'raster',
                        source: 'stamen-terrain',
                        paint: {
                            'raster-opacity': 0.9,
                            'raster-saturation': -0.3
                        }
                    }
                ]
            }
        };

        // Initialize map with globe projection (like Apple Maps)
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            center: [10.0, 50.0],
            zoom: 4.2,
            antialias: true,
            maxZoom: 10,
            minZoom: 2,
            projection: 'globe'
        });

        // Route animation state
        let routeAnimations = [];
        let pulseAnimations = [];
        
        map.on('load', () => {
            // Add strong terrain hillshade - much more visible
            map.addSource('hillshade', {
                type: 'raster',
                tiles: [
                    'https://basemaps.cartocdn.com/rastertiles/voyager_hillshade/{z}/{x}/{y}.png'
                ],
                tileSize: 256
            });
            map.addLayer({
                id: 'hillshade',
                type: 'raster',
                source: 'hillshade',
                paint: { 
                    'raster-opacity': 0.8,
                    'raster-contrast': 0.5,
                    'raster-brightness-max': 1.5
                }
            }, map.getStyle().layers[0].id);

            // Route file mappings with descriptive names
            const routeFiles = [
                { file: 'caledonian.geojson', name: 'London → Edinburgh (Caledonian Sleeper)', speed: 0.8 },
                { file: 'GBCH.geojson', name: 'London → Switzerland', speed: 1.2 },
                { file: 'ITA.geojson', name: 'Bari → Switzerland', speed: 1.5 },
                { file: 'ROMCH.geojson', name: 'Bucharest → Switzerland', speed: 0.8 },
                { file: 'baltic express.geojson', name: 'Switzerland → Helsinki (Baltic Express)', speed: 0.5 },
                { file: 'centraleurope.geojson', name: 'Linz → Prague → Bratislava', speed: 1.0 },
                { file: 'venice.geojson', name: 'Switzerland → Venice', speed: 0.9 }
            ];

            // Load all route files
            const routePromises = routeFiles.map(routeInfo => 
                fetch(`data/${routeInfo.file}`)
                    .then(res => res.json())
                    .then(data => ({ ...routeInfo, data }))
            );

            Promise.all(routePromises)
                .then(routeDataArray => {
                    const routes = [];
                    
                    // Process each route file
                    routeDataArray.forEach((routeInfo, routeIndex) => {
                        const { data, name, speed } = routeInfo;
                        
                        // Process each feature in the GeoJSON
                        if (data.features && data.features.length > 0) {
                            let allCoords = [];
                            
                            // For Baltic Express, include all features (land + ferry)
                            // For other routes, only include the first feature
                            const featuresToProcess = routeInfo.file === 'baltic express.geojson' 
                                ? data.features 
                                : [data.features[0]];
                            
                            featuresToProcess.forEach(feature => {
                                let coords;
                                
                                switch (feature.geometry.type) {
                                    case 'Polygon':
                                        coords = feature.geometry.coordinates[0];
                                        break;
                                    case 'MultiLineString':
                                        coords = feature.geometry.coordinates.flat();
                                        break;
                                    default:
                                        coords = feature.geometry.coordinates;
                                }
                                
                                // Add coordinates to the combined route
                                allCoords = allCoords.concat(coords);
                            });
                            
                            routes.push({
                                type: 'Feature',
                                geometry: { type: 'LineString', coordinates: allCoords },
                                properties: {
                                    routeId: routeIndex,
                                    name: name,
                                    speed: speed,
                                    color: ROUTE_COLORS[routeIndex % ROUTE_COLORS.length]
                                }
                            });
                        }
                    });

                    // Store routes globally for basemap switching
                    globalRoutes = routes;

                    // Create legend with click functionality
                    const legend = document.getElementById('legend');
                    routes.forEach((route, i) => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.id = `legend-item-${i}`;
                        item.innerHTML = `
                            <div class="legend-color" style="background: ${route.properties.color}"></div>
                            <span>${route.properties.name}</span>
                        `;
                        
                        // Add click handler to redraw route
                        item.addEventListener('click', () => {
                            // Set animating state
                            item.classList.remove('completed');
                            item.classList.add('animating');
                            
                            redrawRoute(i, route);
                            
                            // On mobile, collapse the panel after clicking a route
                            if (window.innerWidth <= 768) {
                                const overlay = document.querySelector('.map-overlay');
                                const expandBtn = document.getElementById('expand-btn');
                                if (overlay.classList.contains('expanded')) {
                                    overlay.classList.remove('expanded');
                                    expandBtn.textContent = '▲';
                                }
                            }
                        });
                        
                        legend.appendChild(item);
                    });

                    // Add simple route layers - no glow, no pulses, just basic routes
                    routes.forEach((route, i) => {
                        const routeId = `route-${i}`;
                        
                        // Get appropriate opacity for current basemap
                        const routeOpacity = currentBasemap === 'topo' ? 1.0 : 0.9;
                        
                        // Add source
                        map.addSource(routeId, {
                            type: 'geojson',
                            data: route,
                            lineMetrics: true
                        });

                        // Add simple opaque route layer with sharp gradient for step tracing
                        // Start with routes invisible (0 progress) for the initial animation
                        map.addLayer({
                            id: routeId,
                            type: 'line',
                            source: routeId,
                            layout: {
                                'line-cap': 'round',
                                'line-join': 'round'
                            },
                            paint: {
                                'line-width': 3,
                                'line-opacity': routeOpacity,
                                'line-gradient': [
                                    'step',
                                    ['line-progress'],
                                    route.properties.color, // Full color from 0 to cutoff
                                    0, 'rgba(0,0,0,0)' // Start completely invisible
                                ]
                            }
                        });
                    });

                    // Start simple route tracing animation
                    startSimpleTracingAnimation(routes);
                })
                .catch(err => console.error('Could not load routes:', err));
        });

        // Simple animation tracking
        let routeAnimationFrames = new Map();
        let trackingEnabled = false;
        let cameraAnimationFrame = null;

        function startSimpleTracingAnimation(routes) {
            // Animate all routes on initial load with stagger
            routes.forEach((route, i) => {
                setTimeout(() => {
                    // Set animating state for initial load
                    const legendItem = document.getElementById(`legend-item-${i}`);
                    if (legendItem) {
                        legendItem.classList.add('animating');
                    }
                    
                    simpleRedrawRoute(i, route);
                }, i * 400); // 400ms stagger between each route
            });
        }

        // Function to sample route coordinates based on distance for camera tracking
        function sampleRouteCoordinates(coordinates, numSamples = 10) {
            // Calculate cumulative distances along the route
            const distances = [0];
            let totalDistance = 0;
            
            for (let i = 1; i < coordinates.length; i++) {
                const dx = coordinates[i][0] - coordinates[i-1][0];
                const dy = coordinates[i][1] - coordinates[i-1][1];
                const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                totalDistance += segmentDistance;
                distances.push(totalDistance);
            }
            
            // Sample waypoints based on distance progress
            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                const progress = i / (numSamples - 1); // 0 to 1
                const targetDistance = progress * totalDistance;
                
                // Find the coordinate pair that contains this distance
                let coordIndex = 0;
                for (let j = 1; j < distances.length; j++) {
                    if (distances[j] >= targetDistance) {
                        coordIndex = j - 1;
                        break;
                    }
                }
                
                // Interpolate between coordinates based on distance
                if (coordIndex < coordinates.length - 1) {
                    const segmentProgress = (targetDistance - distances[coordIndex]) / (distances[coordIndex + 1] - distances[coordIndex]);
                    const coord1 = coordinates[coordIndex];
                    const coord2 = coordinates[coordIndex + 1];
                    
                    const interpolatedCoord = [
                        coord1[0] + (coord2[0] - coord1[0]) * segmentProgress,
                        coord1[1] + (coord2[1] - coord1[1]) * segmentProgress
                    ];
                    
                    samples.push({
                        coord: interpolatedCoord,
                        progress: progress
                    });
                } else {
                    samples.push({
                        coord: coordinates[coordinates.length - 1],
                        progress: progress
                    });
                }
            }
            
            return samples;
        }

        // Catmull-Rom spline interpolation for smooth curved camera movement
        function catmullRomSpline(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            
            return [
                0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 + (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3),
                0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 + (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3)
            ];
        }

        // Route redraw with step tracing animation and optional camera tracking
        function simpleRedrawRoute(routeIndex, route) {
            const routeId = `route-${routeIndex}`;
            
            // Cancel any existing animations
            if (routeAnimationFrames.has(routeId)) {
                cancelAnimationFrame(routeAnimationFrames.get(routeId));
                routeAnimationFrames.delete(routeId);
            }
            if (cameraAnimationFrame) {
                cancelAnimationFrame(cameraAnimationFrame);
                cameraAnimationFrame = null;
            }
            
            // Fade out first
            map.setPaintProperty(routeId, 'line-opacity', 0);
            
            // Wait, then start tracing
            setTimeout(() => {
                // Reset route to show nothing using step gradient
                map.setPaintProperty(routeId, 'line-gradient', [
                    'step',
                    ['line-progress'],
                    route.properties.color,
                    0, 'rgba(0,0,0,0)' // Nothing visible initially
                ]);
                
                // Set opacity back to visible
                const currentBasemap = document.querySelector('.basemap-btn.active').dataset.style;
                const routeOpacity = currentBasemap === 'topo' ? 1.0 : 0.9;
                map.setPaintProperty(routeId, 'line-opacity', routeOpacity);
                
                // Prepare camera tracking if enabled
                let trackingWaypoints = [];
                let currentWaypointIndex = 0;
                let nextWaypointIndex = 1;
                if (trackingEnabled) {
                    trackingWaypoints = sampleRouteCoordinates(route.geometry.coordinates, 10);
                }
                
                // Start step tracing animation
                const speedMultiplier = trackingEnabled ? 0.3 : 1.0;
                const duration = (3000 / route.properties.speed) * (1 / speedMultiplier); // Duration based on route speed
                const startTime = performance.now();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use linear progress when tracking is enabled, eased when not
                    const easedProgress = trackingEnabled ? progress : (progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2);
                    
                    // Update step gradient to trace the route as a step function
                    // Show solid color from 0 to current progress, then transparent
                    map.setPaintProperty(routeId, 'line-gradient', [
                        'step',
                        ['line-progress'],
                        route.properties.color,
                        easedProgress, 'rgba(0,0,0,0)'
                    ]);
                    
                    // Update camera position if tracking is enabled - smooth curved movement
                    if (trackingEnabled && trackingWaypoints.length > 0) {
                        let targetWaypoint = null;
                        
                        // Find which waypoints we should be between based on current progress
                        for (let i = 0; i < trackingWaypoints.length - 1; i++) {
                            if (easedProgress >= trackingWaypoints[i].progress && easedProgress <= trackingWaypoints[i + 1].progress) {
                                currentWaypointIndex = i;
                                nextWaypointIndex = i + 1;
                                break;
                            }
                        }
                        
                        // If we're at the end, just use the last waypoint
                        if (easedProgress >= trackingWaypoints[trackingWaypoints.length - 1].progress) {
                            targetWaypoint = trackingWaypoints[trackingWaypoints.length - 1].coord;
                        } else if (currentWaypointIndex < trackingWaypoints.length && nextWaypointIndex < trackingWaypoints.length) {
                            const currentWP = trackingWaypoints[currentWaypointIndex];
                            const nextWP = trackingWaypoints[nextWaypointIndex];
                            
                            // Calculate how far we are between these two waypoints
                            const segmentProgress = (easedProgress - currentWP.progress) / (nextWP.progress - currentWP.progress);
                            const clampedSegmentProgress = Math.max(0, Math.min(1, segmentProgress));
                            
                            // Get control points for smooth spline curve
                            const p0 = currentWaypointIndex > 0 ? trackingWaypoints[currentWaypointIndex - 1].coord : currentWP.coord;
                            const p1 = currentWP.coord;
                            const p2 = nextWP.coord;
                            const p3 = nextWaypointIndex < trackingWaypoints.length - 1 ? trackingWaypoints[nextWaypointIndex + 1].coord : nextWP.coord;
                            
                            // Use Catmull-Rom spline for smooth curved movement
                            targetWaypoint = catmullRomSpline(p0, p1, p2, p3, clampedSegmentProgress);
                        }
                        
                        if (targetWaypoint) {
                            map.setCenter(targetWaypoint);
                        }
                    }
                    
                    if (progress < 1) {
                        const frameId = requestAnimationFrame(animate);
                        routeAnimationFrames.set(routeId, frameId);
                    } else {
                        routeAnimationFrames.delete(routeId);
                        // Ensure it's fully visible at the end
                        map.setPaintProperty(routeId, 'line-gradient', [
                            'step',
                            ['line-progress'],
                            route.properties.color,
                            1, 'rgba(0,0,0,0)'
                        ]);
                        
                        // Update legend item state to completed
                        const legendItem = document.getElementById(`legend-item-${routeIndex}`);
                        if (legendItem) {
                            legendItem.classList.remove('animating');
                            legendItem.classList.add('completed');
                        }
                    }
                }
                
                const frameId = requestAnimationFrame(animate);
                routeAnimationFrames.set(routeId, frameId);
                
            }, 500); // Wait 500ms after fade out before starting trace
        }

        // Add subtle zoom-based styling
        map.on('zoom', () => {
            const zoom = map.getZoom();
            const opacity = Math.max(0.6, Math.min(1, (zoom - 3) / 4));
            
            // Keep terrain strong and visible
            map.setPaintProperty('hillshade', 'raster-opacity', 0.8 * opacity);
        });

        // Add navigation controls
        map.addControl(new maplibregl.NavigationControl({
            showCompass: false,
            showZoom: true
        }), 'top-right');

        // Add fullscreen control
        map.addControl(new maplibregl.FullscreenControl(), 'top-right');

        // Simple function to redraw a specific route
        function redrawRoute(routeIndex, route) {
            simpleRedrawRoute(routeIndex, route);
        }

        // Store route states globally for basemap switching
        let globalRoutes = [];
        let routeAnimationStates = new Map();
        let currentBasemap = 'positron'; // Track current basemap

        // Function to get appropriate colors for current basemap
        function getRouteColors(basemapType) {
            return basemapType === 'topo' ? TOPO_ROUTE_COLORS : ROUTE_COLORS;
        }

        // Add camera mode functionality
        document.querySelectorAll('.camera-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const selectedMode = e.target.dataset.mode;
                
                // If clicking the already active button, do nothing
                if (e.target.classList.contains('active')) {
                    return;
                }
                
                // Remove active class from all camera buttons
                document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                e.target.classList.add('active');
                
                // Update tracking state
                trackingEnabled = selectedMode === 'tracking';
            });
        });

        // Add mobile expand/collapse functionality
        document.getElementById('expand-btn').addEventListener('click', function() {
            const overlay = document.querySelector('.map-overlay');
            const isExpanded = overlay.classList.contains('expanded');
            
            if (isExpanded) {
                overlay.classList.remove('expanded');
                this.textContent = '▲';
            } else {
                overlay.classList.add('expanded');
                this.textContent = '▼';
            }
        });

        // Also allow tapping the header to expand/collapse
        document.querySelector('.mobile-header').addEventListener('click', function(e) {
            // Only trigger if clicking the header itself, not the button
            if (e.target !== document.getElementById('expand-btn')) {
                document.getElementById('expand-btn').click();
            }
        });

        // Add basemap selector functionality
        document.querySelectorAll('.basemap-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const selectedStyle = e.target.dataset.style;
                
                // If clicking the already active button, do nothing
                if (e.target.classList.contains('active')) {
                    return;
                }
                
                // Remove active class from all buttons
                document.querySelectorAll('.basemap-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                e.target.classList.add('active');
                
                // Toggle dark theme class on overlay
                const overlay = document.querySelector('.map-overlay');
                if (selectedStyle === 'dark') {
                    overlay.classList.add('dark-theme');
                } else {
                    overlay.classList.remove('dark-theme');
                }
            const newStyle = BASEMAP_STYLES[selectedStyle];
            currentBasemap = selectedStyle;
            const routeColors = getRouteColors(selectedStyle);
            
            // Clear previous state to avoid conflicts
            routeAnimationStates.clear();
            
            // Change basemap style
            map.setStyle(newStyle);
            
            map.once('style.load', () => {
                // Re-add terrain for styles that need it
                if (selectedStyle !== 'humanitarian' && selectedStyle !== 'topo') {
                    map.addSource('hillshade', {
                        type: 'raster',
                        tiles: [
                            'https://basemaps.cartocdn.com/rastertiles/voyager_hillshade/{z}/{x}/{y}.png'
                        ],
                        tileSize: 256
                    });
                    map.addLayer({
                        id: 'hillshade',
                        type: 'raster',
                        source: 'hillshade',
                        paint: { 
                            'raster-opacity': selectedStyle === 'dark' ? 0.4 : 0.8,
                            'raster-contrast': 0.5,
                            'raster-brightness-max': 1.5
                        }
                    }, map.getStyle().layers[0].id);
                }
                
                // Re-add all route layers with updated colors for the new basemap
                console.log(`Restoring ${globalRoutes.length} routes for basemap: ${selectedStyle}`);
                
                globalRoutes.forEach((route, i) => {
                    const routeId = `route-${i}`;
                    const newColor = routeColors[i % routeColors.length];
                    
                    console.log(`Restoring route ${i} with color ${newColor}`);
                    
                    // Update route color for new basemap
                    route.properties.color = newColor;
                    
                    // Re-add source
                    map.addSource(routeId, {
                        type: 'geojson',
                        data: route,
                        lineMetrics: true
                    });

                    // Get appropriate opacity for current basemap
                    const routeOpacity = selectedStyle === 'topo' ? 1.0 : 0.9;

                    // Add simple opaque route layer with step gradient (same as default)
                    map.addLayer({
                        id: routeId,
                        type: 'line',
                        source: routeId,
                        layout: {
                            'line-cap': 'round',
                            'line-join': 'round'
                        },
                        paint: {
                            'line-width': 3,
                            'line-opacity': routeOpacity,
                            'line-gradient': [
                                'step',
                                ['line-progress'],
                                newColor, // Full color from 0 to cutoff
                                1, 'rgba(0,0,0,0)' // Transparent after cutoff
                            ]
                        }
                    });
                });
            });
            });
        });
    </script>
</body>

</html>