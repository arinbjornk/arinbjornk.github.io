
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Train Journeys by Arinbjörn | Interactive European Railway Map</title>
    <meta name="description" content="Explore long-distance train routes across Europe taken by Arinbjörn Kolbeinsson. Interactive map with animated route tracing and camera tracking.">
    <meta name="keywords" content="Arinbjörn Kolbeinsson, train travel, European railways, interactive map, train routes, rail travel, Europe travel, railway visualization">
    <meta name="author" content="Arinbjörn Kolbeinsson">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://arinbjorn.is/trains/">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Social media meta tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@arinbjornkol">
    <meta name="twitter:title" content="Train Journeys by Arinbjörn | Interactive European Railway Map">
    <meta name="twitter:description" content="Explore long-distance train routes across Europe with interactive animations and camera tracking.">
    <meta name="twitter:image" content="https://arinbjorn.is/trains/preview.jpg">
    
    <meta property="og:title" content="Train Journeys by Arinbjörn | Interactive European Railway Map">
    <meta property="og:url" content="https://arinbjorn.is/trains/">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://arinbjorn.is/trains/preview.jpg">
    <meta property="og:description" content="Explore long-distance train routes across Europe taken by Arinbjörn Kolbeinsson. Interactive map with animated route tracing and camera tracking.">
    <meta property="og:site_name" content="Arinbjörn Kolbeinsson">

    <!-- Structured data for search engines -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebPage",
        "name": "Train Journeys by Arinbjörn",
        "description": "Interactive map showing long-distance train routes across Europe taken by Arinbjörn Kolbeinsson",
        "url": "https://arinbjorn.is/trains/",
        "author": {
            "@type": "Person",
            "name": "Arinbjörn Kolbeinsson",
            "url": "https://arinbjorn.is",
            "sameAs": [
                "https://scholar.google.co.uk/citations?user=MiI7lj0AAAAJ&hl=en",
                "https://github.com/arinbjornk",
                "https://www.linkedin.com/in/arinbjorn",
                "https://bsky.app/profile/arinbjorn.is",
                "https://x.com/arinbjornkol"
            ]
        },
        "mainEntity": {
            "@type": "Map",
            "name": "European Train Routes by Arinbjörn",
            "description": "Interactive visualization of train journeys across Europe"
        },
        "breadcrumb": {
            "@type": "BreadcrumbList",
            "itemListElement": [
                {
                    "@type": "ListItem",
                    "position": 1,
                    "name": "Home",
                    "item": "https://arinbjorn.is"
                },
                {
                    "@type": "ListItem",
                    "position": 2,
                    "name": "Train Journeys",
                    "item": "https://arinbjorn.is/trains/"
                }
            ]
        }
    }
    </script>
    <!-- MapLibre GL JS -->
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet" />
    <!-- Fonts matching your website -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,300;8..60,400&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables matching your website */
        :root {
            --primary-color: #252525;
            --text-color: #333333;
            --background-card: rgba(255, 255, 255, 0.25);
            --theme-rail: #8B4513;      /* Retro brown for railways */
            --theme-vintage: #D2691E;   /* Vintage orange */
            --transition-standard: all 0.3s ease;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #65C0D4;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(10px) saturate(200%);
            -webkit-backdrop-filter: blur(10px) saturate(200%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 350px;
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-color);
            box-shadow: 
                0 8px 32px rgba(31, 38, 135, 0.2), 
                inset 0 2px 10px rgba(255, 255, 255, 0.3);
            transition: var(--transition-standard);
        }

        .map-overlay.dark-theme {
            background: rgba(0, 0, 0, 0.3);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3), 
                inset 0 2px 10px rgba(255, 255, 255, 0.1);
        }

        .map-overlay.dark-theme h3 {
            color: #ffffff;
        }

        .map-overlay.dark-theme p {
            color: #cccccc;
        }

        .map-overlay.dark-theme .basemap-selector label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .camera-mode label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .camera-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .camera-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .map-overlay.dark-theme .camera-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            color: #ffffff;
        }

        .map-overlay.dark-theme .back-link {
            color: #ffffff;
        }

        .map-overlay.dark-theme .attributions p {
            color: #aaa;
        }

        .map-overlay.dark-theme .attributions a {
            color: #aaa;
        }

        .map-overlay.dark-theme .attributions a:hover {
            color: #ffffff;
        }

        .map-overlay.dark-theme .legend-item.animating::after {
            color: #ffffff;
        }

        .map-overlay.dark-theme .basemap-btn {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .basemap-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .map-overlay.dark-theme .basemap-btn.active {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            color: #ffffff;
        }

        .map-overlay h3 {
            font-family: 'Source Serif 4', serif;
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 400;
            color: var(--primary-color);
        }

        .map-overlay p {
            margin: 0 0 10px 0;
            color: #666;
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
            touch-action: manipulation;
        }

        .legend-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
            position: relative;
        }

        .legend-item {
            position: relative;
        }

        .legend-item.animating::after {
            content: '';
            position: absolute;
            right: 6px;
            top: 50%;
            width: 14px;
            height: 14px;
            background-image: url('train-wheel.svg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            transform: translateY(-50%);
            animation: trainWheel 1.5s linear infinite;
            transform-origin: center center;
        }

        .legend-item.completed::after {
            content: '✓';
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: #4CAF50;
            font-weight: bold;
            line-height: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes trainWheel {
            0% { transform: translateY(-50%) rotate(0deg); }
            100% { transform: translateY(-50%) rotate(360deg); }
        }

        .maplibregl-ctrl-logo {
            display: none !important;
        }

        .basemap-selector {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .basemap-selector label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .basemap-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .basemap-btn {
            flex: 1;
            min-width: 50px;
            padding: 6px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 10px;
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition-standard);
            touch-action: manipulation; /* Prevents double-tap zoom */
        }

        .basemap-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .basemap-btn.active {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            color: var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .camera-mode {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .camera-mode label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .camera-buttons {
            display: flex;
            gap: 6px;
            margin-top: 8px;
        }

        .camera-btn {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 10px;
            color: var(--text-color);
            cursor: pointer;
            transition: var(--transition-standard);
            touch-action: manipulation;
        }

        .camera-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .camera-btn.active {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(255, 255, 255, 0.9);
            font-weight: 600;
            color: var(--primary-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .back-link {
            color: var(--primary-color);
            text-decoration: none;
            transition: var(--transition-standard);
        }

        .back-link:hover {
            opacity: 0.7;
        }

        .attributions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .attributions p {
            font-size: 10px;
            line-height: 1.4;
            color: #999;
            margin: 0;
        }

        .attributions a {
            color: #999;
            text-decoration: none;
        }

        .attributions a:hover {
            color: var(--primary-color);
        }

        /* Route Creator */
        .route-creator {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .route-creator label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .station-input-wrapper {
            position: relative;
            margin-bottom: 8px;
        }

        .station-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            font-size: 12px;
            color: var(--text-color);
            box-sizing: border-box;
            transition: var(--transition-standard);
        }

        .station-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.2);
        }

        .station-input::placeholder {
            color: #999;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1001;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .autocomplete-dropdown.visible {
            display: block;
        }

        .autocomplete-item {
            padding: 8px 10px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover,
        .autocomplete-item.selected {
            background: rgba(0, 0, 0, 0.05);
        }

        .autocomplete-item .country {
            font-size: 10px;
            color: #999;
        }

        .add-stop-link {
            display: block;
            font-size: 11px;
            color: #888;
            text-decoration: none;
            cursor: pointer;
            margin: 4px 0 8px 0;
            touch-action: manipulation;
        }

        .add-stop-link:hover {
            color: var(--primary-color);
        }

        .via-input-wrapper {
            position: relative;
            margin-bottom: 8px;
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .via-input-wrapper .autocomplete-dropdown {
            width: calc(100% - 38px); /* Account for remove button */
        }

        .via-input-wrapper .station-input {
            flex: 1;
        }

        .via-input-wrapper .remove-via-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px 8px;
            font-size: 16px;
            line-height: 1;
            border-radius: 4px;
            transition: var(--transition-standard);
            touch-action: manipulation;
        }

        .via-input-wrapper .remove-via-btn:hover {
            background: rgba(255, 0, 0, 0.1);
            color: #c00;
        }

        .create-route-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: var(--transition-standard);
            margin-top: 4px;
            touch-action: manipulation;
        }

        .create-route-btn:hover {
            opacity: 0.9;
        }

        .create-route-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Create your own button (shown in default mode) */
        .create-own-btn {
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            border: 1px dashed rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            background: transparent;
            color: var(--text-color);
            font-size: 12px;
            cursor: pointer;
            transition: var(--transition-standard);
            touch-action: manipulation;
        }

        .create-own-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.5);
        }

        /* User routes legend */
        .user-routes-legend {
            margin-top: 15px;
        }

        .user-routes-legend label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: 500;
            color: #666;
        }

        .user-route-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 6px;
            border-radius: 4px;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.03);
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .user-route-item:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .user-route-item .route-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .user-route-item .route-distance {
            font-size: 10px;
            color: #888;
            white-space: nowrap;
        }

        .share-btn {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            background: transparent;
            color: var(--text-color);
            font-size: 12px;
            cursor: pointer;
            transition: var(--transition-standard);
            touch-action: manipulation;
        }

        .share-btn:hover {
            background: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.3);
        }

        .share-btn.copied {
            background: rgba(76, 175, 80, 0.1);
            border-color: #4CAF50;
            color: #4CAF50;
        }

        .user-route-item .delete-btn {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 2px 6px;
            font-size: 14px;
            line-height: 1;
            border-radius: 3px;
            transition: var(--transition-standard);
        }

        .user-route-item .delete-btn:hover {
            background: rgba(255, 0, 0, 0.1);
            color: #c00;
        }

        /* Back to showcase link */
        .back-to-showcase {
            display: block;
            margin-top: 12px;
            font-size: 11px;
            color: #666;
            text-decoration: none;
            cursor: pointer;
        }

        .back-to-showcase:hover {
            color: var(--primary-color);
        }

        /* Editable map title for create mode */
        .map-title-input {
            display: none;
            width: 100%;
            font-family: 'Source Serif 4', serif;
            font-size: 16px;
            font-weight: 400;
            color: var(--primary-color);
            background: transparent;
            border: none;
            border-bottom: 1px dashed rgba(0, 0, 0, 0.2);
            padding: 0 0 4px 0;
            margin: 0 0 10px 0;
            outline: none;
            box-sizing: border-box;
        }

        .map-title-input::placeholder {
            color: #999;
            font-style: italic;
        }

        .map-title-input:focus {
            border-bottom-color: var(--primary-color);
        }

        /* Hide elements based on mode */
        .create-mode .default-legend,
        .create-mode .create-own-btn {
            display: none;
        }

        .create-mode #overlay-title {
            display: none;
        }

        .create-mode .map-title-input {
            display: block;
        }

        .default-mode .route-creator,
        .default-mode .user-routes-legend,
        .default-mode .back-to-showcase,
        .default-mode .map-title-input {
            display: none;
        }

        /* Dark theme additions */
        .map-overlay.dark-theme .create-own-btn {
            border-color: rgba(255, 255, 255, 0.3);
            color: #ffffff;
        }

        .map-overlay.dark-theme .create-own-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .map-overlay.dark-theme .user-route-item {
            background: rgba(255, 255, 255, 0.05);
        }

        .map-overlay.dark-theme .user-route-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .map-overlay.dark-theme .user-route-item .route-distance {
            color: #999;
        }

        .map-overlay.dark-theme .share-btn {
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .share-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .map-overlay.dark-theme .user-routes-legend label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .back-to-showcase {
            color: #aaa;
        }

        .map-overlay.dark-theme .back-to-showcase:hover {
            color: #ffffff;
        }

        .map-overlay.dark-theme .map-title-input {
            color: #ffffff;
            border-bottom-color: rgba(255, 255, 255, 0.2);
        }

        .map-overlay.dark-theme .map-title-input::placeholder {
            color: #888;
        }

        .map-overlay.dark-theme .map-title-input:focus {
            border-bottom-color: rgba(255, 255, 255, 0.5);
        }

        /* Dark theme for route creator */
        .map-overlay.dark-theme .station-input {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            color: #ffffff;
        }

        .map-overlay.dark-theme .station-input::placeholder {
            color: #aaa;
        }

        .map-overlay.dark-theme .route-creator label {
            color: #cccccc;
        }

        .map-overlay.dark-theme .autocomplete-dropdown {
            background: rgba(30, 30, 30, 0.95);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .map-overlay.dark-theme .autocomplete-item {
            color: #ffffff;
            border-bottom-color: rgba(255, 255, 255, 0.05);
        }

        .map-overlay.dark-theme .autocomplete-item:hover,
        .map-overlay.dark-theme .autocomplete-item.selected {
            background: rgba(255, 255, 255, 0.1);
        }

        .map-overlay.dark-theme .add-stop-link {
            color: #888;
        }

        .map-overlay.dark-theme .add-stop-link:hover {
            color: #fff;
        }

        .map-overlay.dark-theme .remove-via-btn {
            color: #888;
        }

        .map-overlay.dark-theme .remove-via-btn:hover {
            background: rgba(255, 100, 100, 0.2);
            color: #f88;
        }

        /* Desktop header styling */
        .map-overlay h3 {
            font-family: 'Source Serif 4', serif;
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 400;
            color: var(--primary-color);
        }

        /* Hide mobile elements on desktop */
        .mobile-header {
            display: none;
        }

        .expand-button {
            display: none;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            .map-overlay {
                position: fixed;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                max-width: none;
                border-radius: 1rem 1rem 0 0;
                padding: 1rem;
                transform: translateY(calc(100% - 80px));
                transition: transform 0.3s ease;
                z-index: 1000;
            }

            .map-overlay.expanded {
                transform: translateY(0);
            }

            .map-overlay > h3:not(.mobile-header h3) {
                display: none; /* Hide desktop header on mobile */
            }

            .mobile-header h3 {
                font-size: 14px;
                margin: 0;
            }

            .map-overlay p {
                font-size: 12px;
                margin: 0 0 8px 0;
                display: none; /* Hide description when collapsed */
            }

            .map-overlay.expanded p {
                display: block;
            }

            .mobile-header {
                display: flex !important;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 1rem;
                cursor: pointer;
            }

            .expand-button {
                display: block !important;
                background: none;
                border: none;
                color: var(--text-color);
                font-size: 18px;
                cursor: pointer;
                padding: 4px;
                border-radius: 50%;
                transition: var(--transition-standard);
                touch-action: manipulation;
            }

            .expand-button:hover {
                background: rgba(255, 255, 255, 0.1);
            }

            .legend {
                display: none;
            }

            .map-overlay.expanded .legend {
                display: flex;
            }

            /* Compact settings on mobile */
            .basemap-selector,
            .camera-mode {
                display: flex;
                align-items: center;
                gap: 8px;
                margin-top: 10px;
                padding-top: 10px;
            }

            .basemap-selector label,
            .camera-mode label {
                font-size: 10px;
                margin-bottom: 0;
                white-space: nowrap;
                min-width: fit-content;
            }

            .basemap-buttons,
            .camera-buttons {
                flex: 1;
                gap: 3px;
                margin-top: 0;
            }

            .basemap-btn,
            .camera-btn {
                font-size: 9px;
                padding: 4px 5px;
                min-width: unset;
            }

            .attributions {
                margin-top: 10px;
                padding-top: 10px;
                display: none;
            }

            .map-overlay.expanded .attributions {
                display: block;
            }

            /* Prevent iOS auto-zoom on input focus */
            .station-input,
            .map-title-input {
                font-size: 16px;
            }

            /* Hide title input on mobile when collapsed, show only when expanded */
            .create-mode .map-title-input {
                display: none !important;
            }

            .map-overlay.expanded.create-mode .map-title-input {
                display: block !important;
            }

            /* Hide mobile header title when input is visible (to avoid duplication) */
            .map-overlay.expanded.create-mode #mobile-header-title {
                display: none;
            }

            /* Dark theme mobile adjustments */
            .map-overlay.dark-theme .expand-button {
                color: #ffffff;
            }

            .map-overlay.dark-theme .mobile-header h3 {
                color: #ffffff;
            }
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="map-overlay default-mode" id="overlay">
        <h3 id="overlay-title">Train Journeys by Arinbjörn</h3>
        <input type="text" class="map-title-input" id="map-title-input" placeholder="My Train Map" maxlength="40">
        <div class="mobile-header">
            <h3 id="mobile-header-title">Train Journeys</h3>
            <button class="expand-button" id="expand-btn">▲</button>
        </div>
        <p id="overlay-description">Long-distance train routes Arinbjörn has taken across Europe. Click any route below to watch it trace out on the map.</p>
        <p style="margin-top: 15px; font-size: 11px;"><a href="../index.html" class="back-link">← arinbjorn.is</a></p>

        <!-- Default mode: Arinbjörn's routes -->
        <div class="default-legend">
            <div class="legend" id="legend"></div>
            <a href="https://trainmap.app" target="_blank" class="create-own-btn" style="text-decoration: none; text-align: center;">+ Create your own train map →</a>
        </div>

        <!-- Create mode: User's routes -->
        <div class="user-routes-legend">
            <label>Your Routes:</label>
            <div id="user-routes-list"></div>
            <button class="share-btn" id="share-btn" style="display: none;">Share Map</button>
        </div>

        <div class="route-creator">
            <label>Add a Route:</label>
            <div class="station-input-wrapper">
                <input type="text" class="station-input" id="from-station" placeholder="From station..." autocomplete="off">
                <div class="autocomplete-dropdown" id="from-dropdown"></div>
            </div>
            <div id="via-stations-container"></div>
            <div class="station-input-wrapper">
                <input type="text" class="station-input" id="to-station" placeholder="To station..." autocomplete="off">
                <div class="autocomplete-dropdown" id="to-dropdown"></div>
            </div>
            <a class="add-stop-link" id="add-stop-link">+ add stop</a>
            <button class="create-route-btn" id="create-route-btn" disabled>Draw Route</button>
        </div>

        <a class="back-to-showcase" id="back-to-showcase">← Back to Arinbjörn's routes</a>

        <div class="basemap-selector">
            <label>Map Style:</label>
            <div class="basemap-buttons">
                <button class="basemap-btn active" data-style="positron">Clean</button>
                <button class="basemap-btn" data-style="voyager">Detailed</button>
                <button class="basemap-btn" data-style="humanitarian">OSM</button>
                <button class="basemap-btn" data-style="topo">Topo</button>
                <button class="basemap-btn" data-style="dark">Dark</button>
            </div>
        </div>
        <div class="camera-mode">
            <label>View Mode:</label>
            <div class="camera-buttons">
                <button class="camera-btn active" data-mode="static">Static View</button>
                <button class="camera-btn" data-mode="tracking">Follow Route</button>
            </div>
        </div>
        <div class="attributions">
            <p>Rail data: <a href="https://signal.eu.org/osm" target="_blank">signal.eu.org/osm</a><br>
            Stations: <a href="https://github.com/trainline-eu/stations" target="_blank">Trainline</a><br>
            Maps: Carto, OpenStreetMap, Stamen, Stadia Maps<br>
            Built with MapLibre GL JS</p>
        </div>
    </div>

    <script>
        // Financial Times inspired color palette
        const FT_COLORS = {
            background: '#f6f2e7',
            primary: '#990f3d',
            secondary: '#0d7680',
            accent1: '#a7a59b',
            accent2: '#cc8b65',
            accent3: '#6f7755',
            text: '#33302e',
            textLight: '#66605c'
        };

        // Professional route colors inspired by FT style
        const ROUTE_COLORS = [
            '#990f3d', // FT burgundy
            '#0d7680', // teal
            '#cc8b65', // warm orange
            '#6f7755', // olive
            '#9e2f50', // deep pink
            '#2e6091', // blue
            '#b85aa6', // purple
            '#0f5499'  // navy
        ];

        // Enhanced route colors for topographic map - same hues, better contrast
        const TOPO_ROUTE_COLORS = [
            '#d91b60', // brighter burgundy/pink
            '#00acc1', // brighter teal/cyan
            '#ff8a50', // brighter orange
            '#8bc34a', // brighter green
            '#e91e63', // bright pink
            '#1976d2', // bright blue
            '#9c27b0', // bright purple
            '#3f51b5'  // bright indigo
        ];

        // Basemap styles configuration
        const BASEMAP_STYLES = {
            positron: 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json',
            voyager: 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json',
            dark: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
            humanitarian: {
                version: 8,
                sources: {
                    'osm-humanitarian': {
                        type: 'raster',
                        tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenStreetMap contributors'
                    }
                },
                layers: [
                    {
                        id: 'osm-humanitarian',
                        type: 'raster',
                        source: 'osm-humanitarian',
                        paint: {
                            'raster-opacity': 0.75,
                            'raster-saturation': -0.5,
                            'raster-contrast': -0.2,
                            'raster-brightness-max': 0.9
                        }
                    }
                ]
            },
            topo: {
                version: 8,
                sources: {
                    'opentopomap': {
                        type: 'raster',
                        tiles: ['https://a.tile.opentopomap.org/{z}/{x}/{y}.png'],
                        tileSize: 256,
                        attribution: '© OpenTopoMap (CC-BY-SA), © OpenStreetMap contributors'
                    }
                },
                layers: [
                    {
                        id: 'opentopomap',
                        type: 'raster',
                        source: 'opentopomap',
                        paint: {
                            'raster-opacity': 0.85,
                            'raster-saturation': -0.2
                        }
                    }
                ]
            }
        };

        // Initialize map with globe projection (like Apple Maps)
        // Center shifted left on desktop to show British Isles and accommodate legend placement
        const isDesktop = window.innerWidth >= 768;
        const mapCenter = isDesktop ? [5.0, 50.0] : [10.0, 50.0]; // Shift left on desktop to show UK
        
        // Detect system theme preference and set initial basemap
        const prefersDarkTheme = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const initialStyle = prefersDarkTheme ? 'dark' : 'positron';
        const initialBasemapStyle = prefersDarkTheme ? BASEMAP_STYLES.dark : BASEMAP_STYLES.positron;
        
        const map = new maplibregl.Map({
            container: 'map',
            style: initialBasemapStyle,
            center: mapCenter,
            zoom: 4.2,
            antialias: true,
            maxZoom: 10,
            minZoom: 2,
            projection: 'globe'
        });

        // Set initial button states and theme based on system preference
        document.addEventListener('DOMContentLoaded', () => {
            // Update button states
            document.querySelectorAll('.basemap-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.style === initialStyle) {
                    btn.classList.add('active');
                }
            });
            
            // Apply dark theme to overlay if dark basemap is selected
            const overlay = document.querySelector('.map-overlay');
            if (initialStyle === 'dark') {
                overlay.classList.add('dark-theme');
            }
        });

        // Create mode disabled - now on dedicated app at trainmap.app
        const initialHash = window.location.hash;
        const startInCreateMode = false;

        // If starting in create mode, update UI immediately (before map loads)
        if (startInCreateMode) {
            const overlay = document.getElementById('overlay');
            overlay.classList.remove('default-mode');
            overlay.classList.add('create-mode');
            document.getElementById('overlay-title').textContent = 'Create Your Train Map';
            document.getElementById('overlay-description').textContent = 'Search for stations and create your own train route map. Share it with friends!';
            document.getElementById('mobile-header-title').textContent = 'My Train Map';
        }

        // Route animation state
        let routeAnimations = [];
        let pulseAnimations = [];

        map.on('load', () => {
            // Add strong terrain hillshade - much more visible
            map.addSource('hillshade', {
                type: 'raster',
                tiles: [
                    'https://basemaps.cartocdn.com/rastertiles/voyager_hillshade/{z}/{x}/{y}.png'
                ],
                tileSize: 256
            });
            map.addLayer({
                id: 'hillshade',
                type: 'raster',
                source: 'hillshade',
                paint: { 
                    'raster-opacity': 0.8,
                    'raster-contrast': 0.5,
                    'raster-brightness-max': 1
                }
            }, map.getStyle().layers[0].id);

            // Route file mappings with descriptive names
            const routeFiles = [
                { file: 'caledonian.geojson', name: 'London → Edinburgh (Caledonian Sleeper)', speed: 0.8 },
                { file: 'GBCH.geojson', name: 'London → Switzerland', speed: 1.2 },
                { file: 'ITA.geojson', name: 'Bari → Switzerland', speed: 1.5 },
                { file: 'ROMCH.geojson', name: 'Bucharest → Switzerland', speed: 0.8 },
                { file: 'baltic express.geojson', name: 'Switzerland → Helsinki (Baltic Express)', speed: 0.5 },
                { file: 'centraleurope.geojson', name: 'Linz → Prague → Bratislava', speed: 1.0 },
                { file: 'venice.geojson', name: 'Switzerland → Venice', speed: 0.9 }
            ];

            // Load all route files
            const routePromises = routeFiles.map(routeInfo => 
                fetch(`data/${routeInfo.file}`)
                    .then(res => res.json())
                    .then(data => ({ ...routeInfo, data }))
            );

            Promise.all(routePromises)
                .then(routeDataArray => {
                    const routes = [];
                    
                    // Process each route file
                    routeDataArray.forEach((routeInfo, routeIndex) => {
                        const { data, name, speed } = routeInfo;
                        
                        // Process each feature in the GeoJSON
                        if (data.features && data.features.length > 0) {
                            let allCoords = [];
                            
                            // For Baltic Express, include all features (land + ferry)
                            // For other routes, only include the first feature
                            const featuresToProcess = routeInfo.file === 'baltic express.geojson' 
                                ? data.features 
                                : [data.features[0]];
                            
                            featuresToProcess.forEach(feature => {
                                let coords;
                                
                                switch (feature.geometry.type) {
                                    case 'Polygon':
                                        coords = feature.geometry.coordinates[0];
                                        break;
                                    case 'MultiLineString':
                                        coords = feature.geometry.coordinates.flat();
                                        break;
                                    default:
                                        coords = feature.geometry.coordinates;
                                }
                                
                                // Add coordinates to the combined route
                                allCoords = allCoords.concat(coords);
                            });
                            
                            routes.push({
                                type: 'Feature',
                                geometry: { type: 'LineString', coordinates: allCoords },
                                properties: {
                                    routeId: routeIndex,
                                    name: name,
                                    speed: speed,
                                    color: ROUTE_COLORS[routeIndex % ROUTE_COLORS.length]
                                }
                            });
                        }
                    });

                    // Store routes globally for basemap switching
                    globalRoutes = routes;

                    // Create legend with click functionality
                    const legend = document.getElementById('legend');
                    routes.forEach((route, i) => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.id = `legend-item-${i}`;
                        item.innerHTML = `
                            <div class="legend-color" style="background: ${route.properties.color}"></div>
                            <span>${route.properties.name}</span>
                        `;
                        
                        // Add click handler to redraw route
                        item.addEventListener('click', () => {
                            // Set animating state
                            item.classList.remove('completed');
                            item.classList.add('animating');
                            
                            redrawRoute(i, route);
                            
                            // On mobile, collapse the panel after clicking a route
                            if (window.innerWidth <= 768) {
                                const overlay = document.querySelector('.map-overlay');
                                const expandBtn = document.getElementById('expand-btn');
                                if (overlay.classList.contains('expanded')) {
                                    overlay.classList.remove('expanded');
                                    expandBtn.textContent = '▲';
                                }
                            }
                        });
                        
                        legend.appendChild(item);
                    });

                    // Add simple route layers - no glow, no pulses, just basic routes
                    routes.forEach((route, i) => {
                        const routeId = `route-${i}`;
                        
                        // Get appropriate opacity for current basemap
                        const routeOpacity = currentBasemap === 'topo' ? 1.0 : 0.9;
                        
                        // Add source
                        map.addSource(routeId, {
                            type: 'geojson',
                            data: route,
                            lineMetrics: true
                        });

                        // Add simple opaque route layer with sharp gradient for step tracing
                        // Start with routes invisible (0 progress) for the initial animation
                        map.addLayer({
                            id: routeId,
                            type: 'line',
                            source: routeId,
                            layout: {
                                'line-cap': 'round',
                                'line-join': 'round'
                            },
                            paint: {
                                'line-width': 3,
                                'line-opacity': routeOpacity,
                                'line-gradient': [
                                    'step',
                                    ['line-progress'],
                                    route.properties.color, // Full color from 0 to cutoff
                                    0, 'rgba(0,0,0,0)' // Start completely invisible
                                ]
                            }
                        });
                    });

                    // Start simple route tracing animation (only if not in create mode)
                    if (!startInCreateMode) {
                        startSimpleTracingAnimation(routes);
                    }
                })
                .catch(err => console.error('Could not load routes:', err));
        });

        // Simple animation tracking
        let routeAnimationFrames = new Map();
        let trackingEnabled = false;
        let cameraAnimationFrame = null;

        function startSimpleTracingAnimation(routes) {
            // Animate all routes on initial load with stagger
            routes.forEach((route, i) => {
                setTimeout(() => {
                    // Set animating state for initial load
                    const legendItem = document.getElementById(`legend-item-${i}`);
                    if (legendItem) {
                        legendItem.classList.add('animating');
                    }
                    
                    simpleRedrawRoute(i, route);
                }, i * 400); // 400ms stagger between each route
            });
        }

        // Function to sample route coordinates based on distance for camera tracking
        function sampleRouteCoordinates(coordinates, numSamples = 10) {
            // Calculate cumulative distances along the route
            const distances = [0];
            let totalDistance = 0;
            
            for (let i = 1; i < coordinates.length; i++) {
                const dx = coordinates[i][0] - coordinates[i-1][0];
                const dy = coordinates[i][1] - coordinates[i-1][1];
                const segmentDistance = Math.sqrt(dx * dx + dy * dy);
                totalDistance += segmentDistance;
                distances.push(totalDistance);
            }
            
            // Sample waypoints based on distance progress
            const samples = [];
            for (let i = 0; i < numSamples; i++) {
                const progress = i / (numSamples - 1); // 0 to 1
                const targetDistance = progress * totalDistance;
                
                // Find the coordinate pair that contains this distance
                let coordIndex = 0;
                for (let j = 1; j < distances.length; j++) {
                    if (distances[j] >= targetDistance) {
                        coordIndex = j - 1;
                        break;
                    }
                }
                
                // Interpolate between coordinates based on distance
                if (coordIndex < coordinates.length - 1) {
                    const segmentProgress = (targetDistance - distances[coordIndex]) / (distances[coordIndex + 1] - distances[coordIndex]);
                    const coord1 = coordinates[coordIndex];
                    const coord2 = coordinates[coordIndex + 1];
                    
                    const interpolatedCoord = [
                        coord1[0] + (coord2[0] - coord1[0]) * segmentProgress,
                        coord1[1] + (coord2[1] - coord1[1]) * segmentProgress
                    ];
                    
                    samples.push({
                        coord: interpolatedCoord,
                        progress: progress
                    });
                } else {
                    samples.push({
                        coord: coordinates[coordinates.length - 1],
                        progress: progress
                    });
                }
            }
            
            return samples;
        }

        // Catmull-Rom spline interpolation for smooth curved camera movement
        function catmullRomSpline(p0, p1, p2, p3, t) {
            const t2 = t * t;
            const t3 = t2 * t;
            
            return [
                0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 + (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3),
                0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 + (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3)
            ];
        }

        // Route redraw with step tracing animation and optional camera tracking
        function simpleRedrawRoute(routeIndex, route) {
            const routeId = `route-${routeIndex}`;
            
            // Cancel any existing animations
            if (routeAnimationFrames.has(routeId)) {
                cancelAnimationFrame(routeAnimationFrames.get(routeId));
                routeAnimationFrames.delete(routeId);
            }
            if (cameraAnimationFrame) {
                cancelAnimationFrame(cameraAnimationFrame);
                cameraAnimationFrame = null;
            }
            
            // Fade out first
            map.setPaintProperty(routeId, 'line-opacity', 0);
            
            // Wait, then start tracing
            setTimeout(() => {
                // Reset route to show nothing using step gradient
                map.setPaintProperty(routeId, 'line-gradient', [
                    'step',
                    ['line-progress'],
                    route.properties.color,
                    0, 'rgba(0,0,0,0)' // Nothing visible initially
                ]);
                
                // Set opacity back to visible
                const currentBasemap = document.querySelector('.basemap-btn.active').dataset.style;
                const routeOpacity = currentBasemap === 'topo' ? 1.0 : 0.9;
                map.setPaintProperty(routeId, 'line-opacity', routeOpacity);
                
                // Prepare camera tracking if enabled
                let trackingWaypoints = [];
                let currentWaypointIndex = 0;
                let nextWaypointIndex = 1;
                if (trackingEnabled) {
                    trackingWaypoints = sampleRouteCoordinates(route.geometry.coordinates, 10);
                }
                
                // Start step tracing animation
                const speedMultiplier = trackingEnabled ? 0.3 : 1.0;
                const duration = (3000 / route.properties.speed) * (1 / speedMultiplier); // Duration based on route speed
                const startTime = performance.now();
                
                function animate(currentTime) {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use linear progress when tracking is enabled, eased when not
                    const easedProgress = trackingEnabled ? progress : (progress < 0.5 
                        ? 2 * progress * progress 
                        : 1 - Math.pow(-2 * progress + 2, 3) / 2);
                    
                    // Update step gradient to trace the route as a step function
                    // Show solid color from 0 to current progress, then transparent
                    map.setPaintProperty(routeId, 'line-gradient', [
                        'step',
                        ['line-progress'],
                        route.properties.color,
                        easedProgress, 'rgba(0,0,0,0)'
                    ]);
                    
                    // Update camera position if tracking is enabled - smooth curved movement
                    if (trackingEnabled && trackingWaypoints.length > 0) {
                        let targetWaypoint = null;
                        
                        // Find which waypoints we should be between based on current progress
                        for (let i = 0; i < trackingWaypoints.length - 1; i++) {
                            if (easedProgress >= trackingWaypoints[i].progress && easedProgress <= trackingWaypoints[i + 1].progress) {
                                currentWaypointIndex = i;
                                nextWaypointIndex = i + 1;
                                break;
                            }
                        }
                        
                        // If we're at the end, just use the last waypoint
                        if (easedProgress >= trackingWaypoints[trackingWaypoints.length - 1].progress) {
                            targetWaypoint = trackingWaypoints[trackingWaypoints.length - 1].coord;
                        } else if (currentWaypointIndex < trackingWaypoints.length && nextWaypointIndex < trackingWaypoints.length) {
                            const currentWP = trackingWaypoints[currentWaypointIndex];
                            const nextWP = trackingWaypoints[nextWaypointIndex];
                            
                            // Calculate how far we are between these two waypoints
                            const segmentProgress = (easedProgress - currentWP.progress) / (nextWP.progress - currentWP.progress);
                            const clampedSegmentProgress = Math.max(0, Math.min(1, segmentProgress));
                            
                            // Get control points for smooth spline curve
                            const p0 = currentWaypointIndex > 0 ? trackingWaypoints[currentWaypointIndex - 1].coord : currentWP.coord;
                            const p1 = currentWP.coord;
                            const p2 = nextWP.coord;
                            const p3 = nextWaypointIndex < trackingWaypoints.length - 1 ? trackingWaypoints[nextWaypointIndex + 1].coord : nextWP.coord;
                            
                            // Use Catmull-Rom spline for smooth curved movement
                            targetWaypoint = catmullRomSpline(p0, p1, p2, p3, clampedSegmentProgress);
                        }
                        
                        if (targetWaypoint) {
                            map.setCenter(targetWaypoint);
                        }
                    }
                    
                    if (progress < 1) {
                        const frameId = requestAnimationFrame(animate);
                        routeAnimationFrames.set(routeId, frameId);
                    } else {
                        routeAnimationFrames.delete(routeId);
                        // Ensure it's fully visible at the end
                        map.setPaintProperty(routeId, 'line-gradient', [
                            'step',
                            ['line-progress'],
                            route.properties.color,
                            1, 'rgba(0,0,0,0)'
                        ]);
                        
                        // Update legend item state to completed
                        const legendItem = document.getElementById(`legend-item-${routeIndex}`);
                        if (legendItem) {
                            legendItem.classList.remove('animating');
                            legendItem.classList.add('completed');
                        }
                    }
                }
                
                const frameId = requestAnimationFrame(animate);
                routeAnimationFrames.set(routeId, frameId);
                
            }, 500); // Wait 500ms after fade out before starting trace
        }

        // Add subtle zoom-based styling
        map.on('zoom', () => {
            const zoom = map.getZoom();
            const opacity = Math.max(0.6, Math.min(1, (zoom - 3) / 4));
            
            // Keep terrain strong and visible
            map.setPaintProperty('hillshade', 'raster-opacity', 0.8 * opacity);
        });

        // Add navigation controls
        map.addControl(new maplibregl.NavigationControl({
            showCompass: false,
            showZoom: true
        }), 'top-right');

        // Add fullscreen control
        map.addControl(new maplibregl.FullscreenControl(), 'top-right');

        // Simple function to redraw a specific route
        function redrawRoute(routeIndex, route) {
            simpleRedrawRoute(routeIndex, route);
        }

        // Store route states globally for basemap switching
        let globalRoutes = [];
        let routeAnimationStates = new Map();
        let currentBasemap = initialStyle; // Track current basemap (starts with system preference)

        // Function to get appropriate colors for current basemap
        function getRouteColors(basemapType) {
            return basemapType === 'topo' ? TOPO_ROUTE_COLORS : ROUTE_COLORS;
        }

        // Add camera mode functionality
        document.querySelectorAll('.camera-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const selectedMode = e.target.dataset.mode;
                
                // If clicking the already active button, do nothing
                if (e.target.classList.contains('active')) {
                    return;
                }
                
                // Remove active class from all camera buttons
                document.querySelectorAll('.camera-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                e.target.classList.add('active');
                
                // Update tracking state
                trackingEnabled = selectedMode === 'tracking';
            });
        });

        // Add mobile expand/collapse functionality
        document.getElementById('expand-btn').addEventListener('click', function() {
            const overlay = document.querySelector('.map-overlay');
            const isExpanded = overlay.classList.contains('expanded');
            
            if (isExpanded) {
                overlay.classList.remove('expanded');
                this.textContent = '▲';
            } else {
                overlay.classList.add('expanded');
                this.textContent = '▼';
            }
        });

        // Also allow tapping the header to expand/collapse
        document.querySelector('.mobile-header').addEventListener('click', function(e) {
            // Only trigger if clicking the header itself, not the button
            if (e.target !== document.getElementById('expand-btn')) {
                document.getElementById('expand-btn').click();
            }
        });

        // Add basemap selector functionality
        document.querySelectorAll('.basemap-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                const selectedStyle = e.target.dataset.style;
                
                // If clicking the already active button, do nothing
                if (e.target.classList.contains('active')) {
                    return;
                }
                
                // Remove active class from all buttons
                document.querySelectorAll('.basemap-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                e.target.classList.add('active');
                
                // Toggle dark theme class on overlay
                const overlay = document.querySelector('.map-overlay');
                if (selectedStyle === 'dark') {
                    overlay.classList.add('dark-theme');
                } else {
                    overlay.classList.remove('dark-theme');
                }
            const newStyle = BASEMAP_STYLES[selectedStyle];
            currentBasemap = selectedStyle;
            const routeColors = getRouteColors(selectedStyle);
            
            // Clear previous state to avoid conflicts
            routeAnimationStates.clear();
            
            // Change basemap style
            map.setStyle(newStyle);
            
            map.once('style.load', () => {
                // Re-add terrain for styles that need it
                if (selectedStyle !== 'humanitarian' && selectedStyle !== 'topo') {
                    map.addSource('hillshade', {
                        type: 'raster',
                        tiles: [
                            'https://basemaps.cartocdn.com/rastertiles/voyager_hillshade/{z}/{x}/{y}.png'
                        ],
                        tileSize: 256
                    });
                    map.addLayer({
                        id: 'hillshade',
                        type: 'raster',
                        source: 'hillshade',
                        paint: { 
                            'raster-opacity': selectedStyle === 'dark' ? 0.4 : 0.8,
                            'raster-contrast': 0.5,
                            'raster-brightness-max': 1
                        }
                    }, map.getStyle().layers[0].id);
                }
                
                // Re-add all route layers with updated colors for the new basemap
                console.log(`Restoring ${globalRoutes.length} routes for basemap: ${selectedStyle}`);
                
                globalRoutes.forEach((route, i) => {
                    const routeId = `route-${i}`;
                    const newColor = routeColors[i % routeColors.length];
                    
                    console.log(`Restoring route ${i} with color ${newColor}`);
                    
                    // Update route color for new basemap
                    route.properties.color = newColor;
                    
                    // Re-add source
                    map.addSource(routeId, {
                        type: 'geojson',
                        data: route,
                        lineMetrics: true
                    });

                    // Get appropriate opacity for current basemap
                    const routeOpacity = selectedStyle === 'topo' ? 1.0 : 0.9;

                    // Add simple opaque route layer with step gradient (same as default)
                    map.addLayer({
                        id: routeId,
                        type: 'line',
                        source: routeId,
                        layout: {
                            'line-cap': 'round',
                            'line-join': 'round'
                        },
                        paint: {
                            'line-width': 3,
                            'line-opacity': routeOpacity,
                            'line-gradient': [
                                'step',
                                ['line-progress'],
                                newColor, // Full color from 0 to cutoff
                                1, 'rgba(0,0,0,0)' // Transparent after cutoff
                            ]
                        }
                    });
                });
                
                // After re-adding routes, check and update legend states
                // If any routes were animating, they should be marked as completed
                // since the new basemap shows all routes fully drawn
                globalRoutes.forEach((route, i) => {
                    const legendItem = document.getElementById(`legend-item-${i}`);
                    if (legendItem && legendItem.classList.contains('animating')) {
                        legendItem.classList.remove('animating');
                        legendItem.classList.add('completed');
                    }
                });
            });
            });
        });

        // ============================================
        // USER ROUTE CREATION
        // ============================================

        // Fetch route from signal.eu.org API (supports multiple waypoints)
        async function fetchTrainRoute(waypoints) {
            // waypoints is array of {lon, lat} objects
            const coordString = waypoints.map(w => `${w.lon},${w.lat}`).join(';');
            const url = `https://signal.eu.org/osm/eu/route/v1/train/${coordString}?geometries=geojson&overview=full`;

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();

                if (data.routes && data.routes[0] && data.routes[0].geometry) {
                    return {
                        type: 'Feature',
                        geometry: data.routes[0].geometry,
                        properties: {
                            distance: data.routes[0].distance,
                            duration: data.routes[0].duration
                        }
                    };
                } else {
                    throw new Error('No route found');
                }
            } catch (error) {
                console.error('Route fetch error:', error);
                throw error;
            }
        }

        // User-created routes storage
        let userRoutes = [];
        let userRouteCounter = 0;

        // Add a user route to the map
        // waypoints: array of {lon, lat} objects
        // name: route name string
        // skipFitBounds: if true, don't fit map to this route (used when loading multiple routes)
        async function addUserRoute(waypoints, name, skipFitBounds = false) {
            try {
                const routeData = await fetchTrainRoute(waypoints);

                const routeIndex = globalRoutes.length + userRouteCounter;
                const color = ROUTE_COLORS[routeIndex % ROUTE_COLORS.length];

                routeData.properties.routeId = routeIndex;
                routeData.properties.name = name || `Custom Route ${userRouteCounter + 1}`;
                routeData.properties.color = color;
                routeData.properties.speed = 1.0;
                routeData.properties.isUserRoute = true;

                const routeId = `user-route-${userRouteCounter}`;

                // Add source and layer
                map.addSource(routeId, {
                    type: 'geojson',
                    data: routeData,
                    lineMetrics: true
                });

                map.addLayer({
                    id: routeId,
                    type: 'line',
                    source: routeId,
                    layout: {
                        'line-cap': 'round',
                        'line-join': 'round'
                    },
                    paint: {
                        'line-width': 3,
                        'line-opacity': 0.9,
                        'line-gradient': [
                            'step',
                            ['line-progress'],
                            color,
                            0, 'rgba(0,0,0,0)'
                        ]
                    }
                });

                userRoutes.push({ id: routeId, data: routeData });
                userRouteCounter++;

                // Animate the new route
                animateUserRoute(routeId, routeData);

                // Fit map to show the route (unless skipped)
                if (!skipFitBounds) {
                    const coords = routeData.geometry.coordinates;
                    const bounds = coords.reduce((bounds, coord) => {
                        return bounds.extend(coord);
                    }, new maplibregl.LngLatBounds(coords[0], coords[0]));

                    map.fitBounds(bounds, { padding: 50 });
                }

                return routeData;
            } catch (error) {
                console.error('Failed to add route:', error);
                throw error;
            }
        }

        // Animate a user route
        function animateUserRoute(routeId, route) {
            const duration = 3000;
            const startTime = performance.now();

            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 3) / 2;

                map.setPaintProperty(routeId, 'line-gradient', [
                    'step',
                    ['line-progress'],
                    route.properties.color,
                    easedProgress, 'rgba(0,0,0,0)'
                ]);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            requestAnimationFrame(animate);
        }

        // ============================================
        // STATION SEARCH & AUTOCOMPLETE
        // ============================================

        // Normalize string for fuzzy search (remove accents, lowercase)
        function normalizeString(str) {
            return str.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        let stations = [];
        let selectedFromStation = null;
        let selectedToStation = null;
        let viaStations = []; // Array of {element, dropdown, station} objects
        let viaCounter = 0;

        // Load stations data
        fetch('data/stations.json')
            .then(res => res.json())
            .then(data => {
                stations = data;
                console.log(`Loaded ${stations.length} stations`);
            })
            .catch(err => console.error('Failed to load stations:', err));

        // Setup autocomplete for an input
        function setupAutocomplete(inputId, dropdownId, onSelect) {
            const input = document.getElementById(inputId);
            const dropdown = document.getElementById(dropdownId);
            let selectedIndex = -1;

            input.addEventListener('input', () => {
                const query = normalizeString(input.value.trim());
                selectedIndex = -1;

                if (query.length < 2) {
                    dropdown.classList.remove('visible');
                    return;
                }

                // Filter stations matching query (using normalized 's' field)
                const filtered = stations.filter(s => s.s.includes(query));

                // Sort: prioritize main stations (Hbf, SBB, Central, etc.)
                const mainStationPatterns = /( hbf| sbb| centraal| central| hb| hauptbahnhof| gare de lyon| gare du nord| termini| centrale)/i;
                filtered.sort((a, b) => {
                    const aMain = mainStationPatterns.test(a.n) ? 0 : 1;
                    const bMain = mainStationPatterns.test(b.n) ? 0 : 1;
                    if (aMain !== bMain) return aMain - bMain;
                    // Then by name length (shorter = more likely the main one)
                    return a.n.length - b.n.length;
                });

                const matches = filtered.slice(0, 8);

                if (matches.length === 0) {
                    dropdown.classList.remove('visible');
                    return;
                }

                // Render dropdown
                dropdown.innerHTML = matches.map((s, i) => `
                    <div class="autocomplete-item" data-index="${i}">
                        <span>${s.n}</span>
                        <span class="country">${s.c}</span>
                    </div>
                `).join('');

                dropdown.classList.add('visible');

                // Click handlers for items
                dropdown.querySelectorAll('.autocomplete-item').forEach((item, i) => {
                    item.addEventListener('click', () => {
                        selectStation(matches[i]);
                    });
                });
            });

            // Keyboard navigation
            input.addEventListener('keydown', (e) => {
                const items = dropdown.querySelectorAll('.autocomplete-item');
                if (!dropdown.classList.contains('visible') || items.length === 0) return;

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, 0);
                    updateSelection(items);
                } else if (e.key === 'Enter' && selectedIndex >= 0) {
                    e.preventDefault();
                    items[selectedIndex].click();
                } else if (e.key === 'Escape') {
                    dropdown.classList.remove('visible');
                }
            });

            function updateSelection(items) {
                items.forEach((item, i) => {
                    item.classList.toggle('selected', i === selectedIndex);
                });
            }

            function selectStation(station) {
                input.value = station.n;
                dropdown.classList.remove('visible');
                onSelect(station);
                updateCreateButton();
            }

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !dropdown.contains(e.target)) {
                    dropdown.classList.remove('visible');
                }
            });
        }

        // Update create button state
        function updateCreateButton() {
            const btn = document.getElementById('create-route-btn');
            const allViaSelected = viaStations.every(v => v.station !== null);
            btn.disabled = !(selectedFromStation && selectedToStation && allViaSelected);
        }

        // Initialize autocomplete
        setupAutocomplete('from-station', 'from-dropdown', (station) => {
            selectedFromStation = station;
        });

        setupAutocomplete('to-station', 'to-dropdown', (station) => {
            selectedToStation = station;
        });

        // Add a via station input
        function addViaStation() {
            const container = document.getElementById('via-stations-container');
            const viaIndex = viaCounter++;
            const inputId = `via-station-${viaIndex}`;
            const dropdownId = `via-dropdown-${viaIndex}`;

            const wrapper = document.createElement('div');
            wrapper.className = 'via-input-wrapper';
            wrapper.id = `via-wrapper-${viaIndex}`;
            wrapper.innerHTML = `
                <input type="text" class="station-input" id="${inputId}" placeholder="Via station..." autocomplete="off">
                <div class="autocomplete-dropdown" id="${dropdownId}"></div>
                <button class="remove-via-btn" data-via-index="${viaIndex}">×</button>
            `;

            container.appendChild(wrapper);

            // Track this via station
            const viaObj = { index: viaIndex, element: wrapper, station: null };
            viaStations.push(viaObj);

            // Setup autocomplete for this input
            setupAutocomplete(inputId, dropdownId, (station) => {
                viaObj.station = station;
            });

            // Setup remove button
            wrapper.querySelector('.remove-via-btn').addEventListener('click', () => {
                removeViaStation(viaIndex);
            });

            updateCreateButton();
        }

        // Remove a via station input
        function removeViaStation(viaIndex) {
            const idx = viaStations.findIndex(v => v.index === viaIndex);
            if (idx === -1) return;

            const viaObj = viaStations[idx];
            viaObj.element.remove();
            viaStations.splice(idx, 1);

            updateCreateButton();
        }

        // Add stop link handler
        document.getElementById('add-stop-link').addEventListener('click', addViaStation);

        // Create route button handler
        document.getElementById('create-route-btn').addEventListener('click', async () => {
            if (!selectedFromStation || !selectedToStation) return;

            const btn = document.getElementById('create-route-btn');
            const originalText = btn.textContent;
            btn.textContent = 'Drawing...';
            btn.disabled = true;

            try {
                // Build waypoints array: from -> via stations (in order) -> to
                const waypoints = [
                    { lon: selectedFromStation.lon, lat: selectedFromStation.lat },
                    ...viaStations.map(v => ({ lon: v.station.lon, lat: v.station.lat })),
                    { lon: selectedToStation.lon, lat: selectedToStation.lat }
                ];

                // Build route name: "A → B → C"
                const stationNames = [
                    selectedFromStation.n,
                    ...viaStations.map(v => v.station.n),
                    selectedToStation.n
                ];
                const routeName = stationNames.join(' → ');

                await addUserRoute(waypoints, routeName);

                // Clear inputs after success
                document.getElementById('from-station').value = '';
                document.getElementById('to-station').value = '';
                selectedFromStation = null;
                selectedToStation = null;

                // Clear via stations
                viaStations.forEach(v => v.element.remove());
                viaStations = [];

                // On mobile, collapse the panel so user can see the route
                if (window.innerWidth <= 768) {
                    const overlay = document.querySelector('.map-overlay');
                    const expandBtn = document.getElementById('expand-btn');
                    if (overlay.classList.contains('expanded')) {
                        overlay.classList.remove('expanded');
                        expandBtn.textContent = '▲';
                    }
                }
            } catch (error) {
                // Collect all stations to check for city points
                const allStations = [
                    selectedFromStation,
                    ...viaStations.map(v => v.station),
                    selectedToStation
                ];
                const cityPoints = allStations.filter(s => s && s.city);

                if (cityPoints.length > 0) {
                    const cityList = cityPoints.map(s => `"${s.n}"`).join(', ');
                    const firstCity = cityPoints[0];
                    const suggestion = `"${firstCity.n} Hbf" or "${firstCity.n} Central"`;

                    alert(`Could not find a route. ${cityList} may be a city point rather than a station. Try selecting a specific station like ${suggestion}.`);
                } else {
                    alert('Could not find a train route between those stations. They may not be connected by rail.');
                }
            }

            btn.textContent = originalText;
            updateCreateButton();
        });

        // ============================================
        // MODE SWITCHING (Default vs Create)
        // ============================================

        let isCreateMode = false;

        function enterCreateMode() {
            if (isCreateMode) return;
            isCreateMode = true;

            const overlay = document.getElementById('overlay');
            overlay.classList.remove('default-mode');
            overlay.classList.add('create-mode');

            // Update title and description
            document.getElementById('overlay-title').textContent = 'Create Your Train Map';
            document.getElementById('overlay-description').textContent = 'Search for stations and create your own train route map. Share it with friends!';

            // Update mobile header title
            const mapTitle = document.getElementById('map-title-input').value.trim() || 'My Train Map';
            document.getElementById('mobile-header-title').textContent = mapTitle;

            // Hide Arinbjörn's routes from the map
            globalRoutes.forEach((route, i) => {
                const routeId = `route-${i}`;
                if (map.getLayer(routeId)) {
                    map.setLayoutProperty(routeId, 'visibility', 'none');
                }
            });
        }

        function exitCreateMode() {
            if (!isCreateMode) return;
            isCreateMode = false;

            const overlay = document.getElementById('overlay');
            overlay.classList.remove('create-mode');
            overlay.classList.add('default-mode');

            // Restore title and description
            document.getElementById('overlay-title').textContent = 'Train Journeys by Arinbjörn';
            document.getElementById('overlay-description').textContent = 'Long-distance train routes Arinbjörn has taken across Europe. Click any route below to watch it trace out on the map.';
            document.getElementById('mobile-header-title').textContent = 'Train Journeys';

            // Show Arinbjörn's routes again
            globalRoutes.forEach((route, i) => {
                const routeId = `route-${i}`;
                if (map.getLayer(routeId)) {
                    map.setLayoutProperty(routeId, 'visibility', 'visible');
                }
            });

            // Remove user routes from map
            userRoutes.forEach(r => {
                if (map.getLayer(r.id)) map.removeLayer(r.id);
                if (map.getSource(r.id)) map.removeSource(r.id);
            });
            userRoutes = [];
            userRouteCounter = 0;

            // Clear hash
            history.replaceState(null, '', window.location.pathname);

            // Clear user routes list
            document.getElementById('user-routes-list').innerHTML = '';

            // Clear via stations
            viaStations.forEach(v => v.element.remove());
            viaStations = [];

            // Clear map title
            document.getElementById('map-title-input').value = '';
        }

        // Update user routes list UI
        function updateUserRoutesList() {
            const list = document.getElementById('user-routes-list');
            list.innerHTML = userRoutes.map((r, i) => {
                const distanceKm = Math.round(r.data.properties.distance / 1000);
                return `
                <div class="user-route-item" data-index="${i}">
                    <div class="legend-color" style="background: ${r.data.properties.color}; width: 16px; height: 3px; border-radius: 2px;"></div>
                    <span class="route-name">${r.data.properties.name}</span>
                    <span class="route-distance">${distanceKm} km</span>
                    <button class="delete-btn" data-index="${i}">×</button>
                </div>
            `}).join('');

            // Add click handlers for replay
            list.querySelectorAll('.user-route-item').forEach((item, i) => {
                item.addEventListener('click', () => {
                    const route = userRoutes[i];
                    if (route) {
                        animateUserRoute(route.id, route.data);

                        // Fit map to show the route
                        const coords = route.data.geometry.coordinates;
                        const bounds = coords.reduce((bounds, coord) => {
                            return bounds.extend(coord);
                        }, new maplibregl.LngLatBounds(coords[0], coords[0]));
                        map.fitBounds(bounds, { padding: 50 });

                        // On mobile, collapse the panel
                        if (window.innerWidth <= 768) {
                            const overlay = document.querySelector('.map-overlay');
                            const expandBtn = document.getElementById('expand-btn');
                            if (overlay.classList.contains('expanded')) {
                                overlay.classList.remove('expanded');
                                expandBtn.textContent = '▲';
                            }
                        }
                    }
                });
            });

            // Add delete handlers (stop propagation so it doesn't trigger replay)
            list.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const index = parseInt(e.target.dataset.index);
                    deleteUserRoute(index);
                });
            });

            // Show/hide share button based on whether there are routes
            const shareBtn = document.getElementById('share-btn');
            shareBtn.style.display = userRoutes.length > 0 ? 'block' : 'none';
        }

        // Delete a user route
        function deleteUserRoute(index) {
            const route = userRoutes[index];
            if (!route) return;

            // Remove from map
            if (map.getLayer(route.id)) map.removeLayer(route.id);
            if (map.getSource(route.id)) map.removeSource(route.id);

            // Remove from array
            userRoutes.splice(index, 1);

            // Update UI and hash
            updateUserRoutesList();
            encodeRoutesToHash();

            // If no routes left, clear hash
            if (userRoutes.length === 0) {
                history.replaceState(null, '', window.location.pathname + '#create');
            }
        }

        // Create mode is now on dedicated app at trainmap.app
        // This site only shows the showcase

        // ============================================
        // URL HASH ENCODING
        // ============================================

        // Encode routes to URL hash
        function encodeRoutesToHash() {
            if (userRoutes.length === 0) return;

            const mapTitle = document.getElementById('map-title-input').value.trim();

            const routeStrings = userRoutes.map(r => {
                const props = r.data.properties;
                // Store waypoints from the route name (A → B → C format)
                // We'll encode using coordinates from the geometry
                // Format: "lat1,lon1,lat2,lon2,...,name" where coordinates are waypoints
                const coords = r.data.geometry.coordinates;
                const from = coords[0];
                const to = coords[coords.length - 1];

                // For now, encode start and end (via points are baked into the geometry)
                // The name contains the full route info like "A → B → C"
                const name = encodeURIComponent(props.name);
                return `${from[1].toFixed(4)},${from[0].toFixed(4)},${to[1].toFixed(4)},${to[0].toFixed(4)},${name}`;
            });

            // Format: #t=Title&r=routes or just #r=routes if no title
            let hash = 'r=' + routeStrings.join('|');
            if (mapTitle) {
                hash = 't=' + encodeURIComponent(mapTitle) + '&' + hash;
            }
            window.location.hash = hash;
        }

        // Decode routes and title from URL hash
        function decodeHashData() {
            const hash = window.location.hash;
            if (!hash || hash.length < 2) return { title: null, routes: [] };

            const hashContent = hash.substring(1); // Remove #
            let title = null;
            let routeString = '';

            // Parse hash parameters
            if (hashContent.includes('&')) {
                const parts = hashContent.split('&');
                for (const part of parts) {
                    if (part.startsWith('t=')) {
                        title = decodeURIComponent(part.substring(2));
                    } else if (part.startsWith('r=')) {
                        routeString = part.substring(2);
                    }
                }
            } else if (hashContent.startsWith('r=')) {
                routeString = hashContent.substring(2);
            } else if (hashContent.startsWith('t=')) {
                title = decodeURIComponent(hashContent.substring(2));
            }

            if (!routeString) return { title, routes: [] };

            const routes = routeString.split('|').map(str => {
                const parts = str.split(',');
                if (parts.length < 4) return null;

                // Parse coordinate pairs (always in lat,lon pairs)
                const waypoints = [];
                let i = 0;
                while (i < parts.length - 1) {
                    const lat = parseFloat(parts[i]);
                    const lon = parseFloat(parts[i + 1]);
                    if (isNaN(lat) || isNaN(lon)) break;
                    waypoints.push({ lat, lon });
                    i += 2;
                }

                if (waypoints.length < 2) return null;

                // Remaining parts are the name
                const name = i < parts.length ? decodeURIComponent(parts.slice(i).join(',')) : 'Shared Route';

                return { waypoints, name };
            }).filter(Boolean);

            return { title, routes };
        }

        // Load routes from URL hash on page load
        async function loadRoutesFromHash() {
            const { title, routes } = decodeHashData();

            // Set the map title if provided
            if (title) {
                document.getElementById('map-title-input').value = title;
                document.getElementById('mobile-header-title').textContent = title;
            } else {
                document.getElementById('mobile-header-title').textContent = 'My Train Map';
            }

            if (routes.length === 0) return;

            console.log(`Loading ${routes.length} routes from URL...`);

            for (const route of routes) {
                try {
                    // Convert waypoints from {lat, lon} to {lon, lat} for the API
                    const waypoints = route.waypoints.map(w => ({ lon: w.lon, lat: w.lat }));
                    await addUserRoute(waypoints, route.name, true); // skipFitBounds = true
                } catch (error) {
                    console.error('Failed to load route from hash:', route.name, error);
                }
            }

            // Fit map to show ALL user routes
            if (userRoutes.length > 0) {
                const allCoords = userRoutes.flatMap(r => r.data.geometry.coordinates);
                const bounds = allCoords.reduce((bounds, coord) => {
                    return bounds.extend(coord);
                }, new maplibregl.LngLatBounds(allCoords[0], allCoords[0]));

                map.fitBounds(bounds, { padding: 50 });
            }
        }

        // Update hash whenever a route is added
        const originalAddUserRoute = addUserRoute;
        addUserRoute = async function(...args) {
            const result = await originalAddUserRoute.apply(this, args);
            updateUserRoutesList();
            encodeRoutesToHash();
            return result;
        };

        // Update hash and mobile header when title changes
        document.getElementById('map-title-input').addEventListener('input', (e) => {
            // Update mobile header to match
            const title = e.target.value.trim() || 'My Train Map';
            document.getElementById('mobile-header-title').textContent = title;

            if (userRoutes.length > 0) {
                encodeRoutesToHash();
            }
        });

        // Share button handler
        document.getElementById('share-btn').addEventListener('click', async () => {
            const shareBtn = document.getElementById('share-btn');
            const mapTitle = document.getElementById('map-title-input').value.trim() || 'My Train Map';
            const shareUrl = window.location.href;

            // Try Web Share API first (mainly mobile)
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: mapTitle,
                        text: `Check out my train map: ${mapTitle}`,
                        url: shareUrl
                    });
                } catch (err) {
                    // User cancelled or error - ignore
                    if (err.name !== 'AbortError') {
                        console.error('Share failed:', err);
                    }
                }
            } else {
                // Fallback: copy to clipboard
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    const originalText = shareBtn.textContent;
                    shareBtn.textContent = 'Link Copied!';
                    shareBtn.classList.add('copied');
                    setTimeout(() => {
                        shareBtn.textContent = originalText;
                        shareBtn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Copy failed:', err);
                    // Final fallback: prompt
                    prompt('Copy this link:', shareUrl);
                }
            }
        });

        // Load routes from hash once map is ready
        map.on('load', () => {
            if (startInCreateMode) {
                // Set mode flag (UI already updated above)
                isCreateMode = true;

                // Load shared routes after a short delay for map to settle
                if (initialHash.startsWith('#r=') || initialHash.startsWith('#t=')) {
                    setTimeout(loadRoutesFromHash, 500);
                }
            }
        });

        console.log('Station search ready');
    </script>
</body>

</html>